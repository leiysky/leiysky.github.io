---
title: Docker不完全指南
date: 2018-12-20 12:33:05
tags: Docker
---

## Docker 简介

虚拟化一直以来都是云计算领域重要的概念。有了虚拟化，对于云提供商而言，机器的资源更便于管理和分配，于用户而言，则是消除了物理机的概念，在隔离环境下搭建属于自己的云服务变得十分容易。

但是传统的虚拟化技术，多多少少都会有性能上的损失，一方面是浪费了计算资源，另一方面管理起来也十分不便。他们大多有一个共同的特点，就是提供了一个与物理机使用上较为相似的虚拟机环境。

那么云服务一定需要一个虚拟机的环境吗？答案是否定的。

这就有了`Docker`。

`Docker`是容器虚拟化技术的一个成功的实现。他抽象出的容器概念最大程度的简化了虚拟环境的概念。你可以将一个`Docker`容器作为一个虚拟机环境使用，也可以作为一个服务的运行环境。

`Docker`优点主要有：
* 性能高，不会像传统的硬件虚拟化丢失那么多IO或者运算性能
* 跨平台能力强
* 打包部署流程方便

## Docker 基本概念

在开始讲`Docker`的使用之前，需要先介绍几个`Docker`中的核心概念，这样方便我们理解`Docker`在生产中的作用，也能很好地帮助我们找到最佳实践。

### Docker 容器

使用`Docker`作为部署环境的应用都是运行在`Docker`容器中的。每个容器都有一个`Container ID`，用于标识这个容器。此外还有`name`等属性，详情可以参考[官方文档](https://docs.docker.com)（可能需要科学上网）。

每个容器都来源于`Docker Image`镜像，你可以将一个容器理解为一个镜像的实例。

容器有几种状态：`created`, `running`, `restarting`, `removing`, `paused`, `exited`, `dead`。

在这里就不展开来讲，但大家可以发现这些状态与一个服务的状态很相似。我们可以将容器的概念扩展为：**基于一个镜像搭建的服务的实例**。

在使用容器时，有几个需要注意的地方：
* 容器不会自己保存状态，你对其进行的一切修改都将在重启容器后消失
* 最好将与docker相关的应用加入到docker用户组中

### Docker 镜像

在`Docker`中镜像是一个很重要的概念，我们的容器都源自于此。

`Docker Image`是由`Docker`的提供商提供的镜像。

比如说`Ubuntu`提供的`ubuntu:16.04`镜像，就是一个典型的`Docker Image`。

这个镜像就是一个`Ubuntu 16.04`的系统实例，你可以使用`docker run`来运行它。运行成功后就可以创建出一个`ubuntu:16.04`的容器。在这个容器里，你可以像使用一个真正的`Ubuntu`系统那样来使用它（像是虚拟机）。

不过一般来说`Docker`是不提倡用户将容器作为一个虚拟机来使用的，这与他的设计理念以及实现方式有关，这部分后面会展开来讲。

一个`Docker Image`的**标识**由几部分组成，比如说`registry.vmatrix.org.cn/mysql:5.7`这个镜像：
* `registry.vmatrix.org.cn/`这部分表示镜像的`Registry`（这也是个Docker的概念，后面会提到，注意和`Repository`区分）。默认是`docker.io/`，在没有指定这部分的情况下会使用默认值。
* `mysql`这部分是镜像的`repository`，它并不会定位到一个具体的镜像，只是定向到了一个镜像仓库，里面包含了镜像的各个版本。
* `:5.7`是镜像的`tag`，即对于具体镜像版本的标识，在没有指定具体值时一般会使用`latest`（某些`Registry`没有提供latest，最好还是指明）。

### Docker client & dockerd

以上几个都是`Docker`设计上的一些概念，涉及到具体使用时，我们需要借助`Docker client`和`dockerd`来管理镜像和容器。

`Docker client`，顾名思义，就是一个`Docker`的客户端程序。我们可以使用它来`拉取(pull)`，`推送(push)`，`运行(run)`镜像。

但是实际上客户端并不会真的做这些事情，他只是帮助用户去调用`Docker`的相关API。

实际上干这些脏活累活的是`dockerd`。`dockerd`是`Docker Daemon`的缩写，比较常见的`UNIX`程序明明方式。顾名思义，它是一个守护进程，负责`docker`容器的调度，资源分配，生命周期维护等等。

打个比方，如果`Docker`容器是码头上的各个集装箱，里面有各种各样的货物，甚至有人在办公，那么`Docker client`就是码头的**客服中心**，`dockerd`就是整个包含了码头工人，码头起重机等的码头系统。与事实有些出入的地方可能就是`dockerd`实际上负责的事情更多一些。

## Docker 实践

介绍完了Docker的一些基本概念，我们可以开始做一些实践了。

现在有一个场景：
* 有一个Web项目需要部署到云平台上，现在云平台提供商提供了一套上传docker镜像进行部署的方式
* 该项目包括几部分：前端（需要静态文件代理），服务端（由Golang编写，仅一个二进制文件，但是只能在指定系统运行），数据库

我们来一个渐进式的探索。

### 方案一

> 使用物理机进行部署。要什么云平台。

步骤如下：
* 安装一个`Ubuntu 18.04`系统
* 配置一下用户名密码之类的
* 安装`Golang 1.11`，`Nginx`，`MySQL 8.0`
* 服务端：把代码拉下来放到某个文件夹，编译后启动
* 前端：把前端资源打包，放到某个文件夹，启动nginx，配置静态文件代理，配置文件放到`/etc/nginx/conf.d/default.conf`
* 数据库：启动mysqld，配置用户名，创建数据库，建表etc。

好了，花了一天时间终于部署完了，可累死我了。

这个时候老板突然打了个电话过来：“喂，PT呀，咱们那台机器是不是还没跑满？”（此处主人公名叫PT）

“嗯，对啊。”

“那再部署一个服务没问题吧？”

“当然OK。”

于是新的工单过来了，看了一眼需求：
* MySQL 5.6
* Golang <= 1.4

我擦，这个版本完全错开了，还得多开实例？

麻烦死了，还是不直接用物理机了。

### 方案二

> 使用虚拟机部署环境，虚拟机使用某知名开源（免费）软件

又搞了一天，总算是弄完了。在物理机上开了两个虚拟机实例，分别跑的不同的服务。

这次我留了个心眼，把虚拟机镜像做了备份，到时候部署的时候，嘻嘻嘻。

这时，老板又来电话了：“PT呀，有个客户买了我们的服务，你去给他们部署一套吧。”

“那路费住宿费……”

“统统报销。”

“好嘞～”

嘿嘿，部署给他一下子搞定，剩下的时间还可以拿来出去玩玩，权当多放一天假了。

于是PT带着电脑，揣着备份的镜像，一路哼着歌到了对方公司。

“您好，我是来给你们部署服务的。”

“欢迎欢迎，这边请。”

对方公司技术人员打开了一台PC机：“您就装在这台电脑上吧。”

PT吓了一跳，定睛一看，什么？居然是Windows？

“这年头还有用windows做部署的公司……”PT暗自想到，心里充满了不屑。

但是到部署的时候他就感受到蛋疼了。

自己使用的虚拟机软件没有Windows版本的，无法部署。

“这年头还有不兼容Windows的软件？？？”

PT实在没有办法了，只能以版本不兼容为理由，回公司重新准备一套服务部署方案。

美好的出差时光就这样没了，自己还要多掏一趟路费，PT心中暗自下了决定，以后再也不在生产环境用这种开源软件。

### 方案三

PT决定使用Docker来做部署。

他使用了最原始的方法（以下方式十分危险，请勿学习）：
* 装了一个`Docker`
* `pull`了一个`ubuntu:16.04`镜像
* 在镜像中运行`bash`，安装所需软件
* 在镜像中编译，部署
* `commit`

这样一来一个跨平台的服务镜像就完成了。虽然体积有点大，有足足50GB，但是好歹能部署了。

什么，你问怎么发新版本？当然是写一个脚本，`docker cp`到容器里替换掉原来的文件，然后`commit`。

几个月之后PT发现这个容器已经100GB了，再这样下去硬盘迟早要撑不住。

于是他决定再换一个方式。

### 方案四

PT终于学会了写`Dockerfile`。

他为每个部分写了Dockerfile。

前端：
```dockerfile
FROM nginx:stable-alpine
COPY . /www
RUN cd /www &&\
    npm run lint &&\
    npm run test &&\
    npm run build
ENTRYPOINT nginx start
```

服务端：
```dockerfile
FROM golang:1-alpine
COPY . /www
RUN cd /www &&\
    go test &&\
    go build &&\
ENTRYPOINT ./www/main
```

数据库则是直接用的`MySQL:8.0`的镜像。

除此之外，他还学会了使用`docker-compose`来管理项目，为了解决每次拉取镜像速度很慢的问题还搭建了公司的`registry`。他做得越来越有模有样了，也得到了老板的嘉奖，或许还有机会提薪。

学会了`Docker`之后，PT终于走上了人生巅峰。

## 总结

以上的实践内容虽是戏说，但也是基于实际的业务场景的。使用`Docker`能大大降低部署的成本，但也需要掌握正确的使用方法。

具体的`Dockerfile`写法还需参考官方文档。

关于为什么不使用`commit`，有兴趣的同学可以自己思考一下，再结合`Docker`的[源码](https://www.github.com/docker/docker-ce)或是分析的博客，做更深一步的探索。笔者学识尚浅，也只能讲这么多。

另外推荐大家使用Matrix的`registry`: [https://registry.vmatrix.org.cn](https://registry.vmatrix.org.cn)

需要账号的可以找博主要，目前收录了一些常用的镜像（比如`alpine`），也可以进一步引入更多镜像。