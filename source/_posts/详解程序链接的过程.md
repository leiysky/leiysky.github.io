---
title: 详解程序链接的过程
date: 2018-11-03 18:58:59
tags:
---
## 前言

> 链接(linking)是将代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。

这是关于链接的一段定义。在静态语言中，链接是十分重要的概念。

理解了链接的整个过程可以帮助我们避免一些编程的错误，同时加强我们对操作系统的了解。

本文主要参考自CSAPP第三版，旨在总结。

## 编译器驱动程序

考虑一个程序：
```c
// main.c
int sum(int *a, int n);

int array[2] = {1, 2};

int main() {
  int val = sum(array, 2);
  return val;
}

// sum.c
int sum(int *a, int n) {
  int i, s = 0;

  for (i = 0; i< n; i++) {
    s += a[i];
  }
  return s;
}
```

在进行编译的过程中，编译器会调用预处理器，编译器，汇编器和链接器。

比如使用：
```shell
$ gcc -Og -o a.out main.c sum.c
```
可以编译出一个可执行二进制文件`a.out`。

首先使用预处理器`cpp`将`main.c`编译器成**ASCII**码的中间文件`main.i`：
```shell
$ cpp main.c /tmp/main.i
```

之后使用`cc1`编译器编译成**ASCII**汇编文件`main.s`：
```shell
$ cc1 /tmp/main.i -Og -o /tmp/main.s
```

之后运行汇编器将`main.s`编译成一个可重定位目标文件(relocatable object file)`main.o`；
```shell
$ as -o /tmp/main.o /tmp/main.s
```

对于`sum.c`，编译器通过相同的过程生成一个`sum.o`。

最后通过链接器`ld`将`main.o`和`sum.o`与一些系统目标文件组合，创建一个可执行文件(executable object file)。
```shell
$ ld -o a.out /tmp/main.o /tmp/sum.o
```

之后通过执行：
```shell
./a.out
```
可以通过加载器(loader)运行该文件。它将`a.out`中的代码和数据copy到内存中，并将控制转移到该程序的开头。

## 静态链接

静态链接器(static linker)将一组可重定位目标文件生成一个可执行文件。

每个可重定向文件都分为很多节(section)。

链接器主要有两个任务：
* 符号解析(symbol resolution)，将符号的**引用**和**定义**关联起来
* 重定位(relocation)，把符号的定义与内存位置关联起来

## 目标文件

目标文件主要有三种：
* 可重定位目标文件，包含二进制代码和数据
* 可执行目标文件，可直接被加载到内存执行
* 共享目标文件，特殊类型的可重定位目标文件，可以运行时动态加载

Windows使用PE格式，macOSX使用Mach-O，Linux和Unix使用ELF(Executable and Linkable Format)

## 可重定位目标文件

以下是一个ELF文件的格式：
||
|:--:|
|ELF头|
|.text|
|.rodata|
|.data|
|.bss|
|.symtab|
|.rel.text|
|.rel.data|
|.debug|
|.line|
|.strtab|
|头部表|
||

* `ELF头`：以一个16字节的序列开始，描述了生成该文件的系统的字长和字节顺序。剩下的部分包括了帮助链接器语法分析和解释目标文件的信息。
* `.text`：程序的机器码
* `.rodata`：read-only数据，比如`printf`中的**format string**和`switch`语句的跳转表
* `.data`：已初始化的全局和静态C变量。局部变量运行时在栈中存储
* `.bss`：未初始化的全局和静态C变量，以及初始化为0的全局或静态变量。未初始化的变量**不占用存储空间**，只占一个符号。在内存中会初始化为0
* `.symtab`：符号表，不包括局部变量
* `.rel.text`：记录`.text`中位置的列表
* `.re.data`：被引用或定义的所有全局变量的重定位信息
* `.debug`：调试符号表
* `.line`：原始行号和`.text`指令的映射，和`.debug`都是使用`-g`选项才会出现
* `.strtab`：字符串表，包括`.symtab`和`.debug`中的符号表。

## 符号和符号表

符号有三种：
* 当前模块定义的能被其他模块引用的**全局符号**，对应非静态的C函数和全局变量
* 由其他模块定义并被当前模块引用的**全局符号**，称为**外部符号**，对应其他模块的非静态C函数和全局变量
* 只被当前模块引用的**局部符号**。对应static函数和static全局变量

ELF符号表：
```c
typedef struct {
  int   name; // 字符串表字节偏移
  char  type:4,
        binding:4;
  char  reserved；
  short section；
  long  value; // 符号地址
  long  size;
}
```

## 符号解析

符号解析中很大的一个问题就是不同模块中的全局符号的解析。

如果编译器遇到了一个不是当前模块定义的符号，会假设该符号是其他模块定义的。如果链接器找不到这个符号，就会输出一条很难解读的错误信息(undefined reference to ...)。

编译器解析多重定义的符号的规则：
1. 不允许有多个同名的强符号
2. 如果有一个强符号和多个弱符号同名，选择强符号
3. 如果多个弱符号同名，随机选一个(巨坑)

其中，**强符号**指的是初始化的全局变量和函数，**弱符号**是未初始化的全局变量和函数。

## 链接静态库

Linux中静态库的存储形式是**archive**，后缀为`.a`
使用`ar`生成静态库：
```shell
$ gcc -c xxx.c aaa.c
$ ar rcs libxxx.a xxx.o aaa.o
```

## 重定位

根据重定位条目进行重定位。代码的重定位条目在`.rel.text`中，已初始化数据的重定位条目放在`.rel.data`中。

ELF重定位条目格式：
```c
typedef struct {
  long offset; // 偏移量
  long typeL:32; 
       symbol:32; 
  long addend;
} Elf64_Rela;
```

ELF有32种重定位类型，主要关注两种：
* `R_X86_64_PC32`：重定位使用32位PC相对地址的引用
* `R_X86_64_32`：重定位使用32位绝对地址的引用

重定位PC相对引用时：
1. 首先确定section的偏移量`ADDR(s)`
2. 加上偏移量`offset`
3. CPU的`PC`压入栈中，加上`addend`

重定位绝对引用时只需对当前位置处理即可。

