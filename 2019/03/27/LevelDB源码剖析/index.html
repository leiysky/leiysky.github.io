<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="前言LevelDB是谷歌开源的一款高性能嵌入式 kv 数据库，基于LSM-tree索引，是Bigtable的简化版实现（可以这么理解）。 它的特点是写入速度非常快，达到了O(1)级别的时间复杂度。但是付出的代价就是读取的速度非常慢，尤其是对于数据库中不存在的 key 进行get操作会扫描所有的记录。 对于 LevelDB 的具体设计本文就不再提及，这里主要从代码的层面分析一下 LevelDB 的结">
<meta property="og:type" content="article">
<meta property="og:title" content="LevelDB源码剖析">
<meta property="og:url" content="http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/index.html">
<meta property="og:site_name" content="leiysky&#39;s blog">
<meta property="og:description" content="前言LevelDB是谷歌开源的一款高性能嵌入式 kv 数据库，基于LSM-tree索引，是Bigtable的简化版实现（可以这么理解）。 它的特点是写入速度非常快，达到了O(1)级别的时间复杂度。但是付出的代价就是读取的速度非常慢，尤其是对于数据库中不存在的 key 进行get操作会扫描所有的记录。 对于 LevelDB 的具体设计本文就不再提及，这里主要从代码的层面分析一下 LevelDB 的结">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://leveldb-handbook.readthedocs.io/zh/latest/_images/sstable_logic.jpeg">
<meta property="og:image" content="https://leveldb-handbook.readthedocs.io/zh/latest/_images/indexblock_format.jpeg">
<meta property="og:image" content="https://leveldb-handbook.readthedocs.io/zh/latest/_images/entry_format.jpeg">
<meta property="article:published_time" content="2019-03-26T16:32:35.000Z">
<meta property="article:modified_time" content="2022-05-27T03:32:31.958Z">
<meta property="article:author" content="leiysky">
<meta property="article:tag" content="Database">
<meta property="article:tag" content="LevelDB">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leveldb-handbook.readthedocs.io/zh/latest/_images/sstable_logic.jpeg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>LevelDB源码剖析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/leiysky">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2019/07/29/%E4%BD%BF%E7%94%A8ANTLR4%E7%BC%96%E5%86%99parser/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2018/10/03/Redis%E7%9A%84LRU%E7%BC%93%E5%AD%98/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&text=LevelDB源码剖析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=LevelDB源码剖析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&is_video=false&description=LevelDB源码剖析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=LevelDB源码剖析&body=Check out this article: http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=LevelDB源码剖析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=LevelDB源码剖析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=LevelDB源码剖析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=LevelDB源码剖析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&name=LevelDB源码剖析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&t=LevelDB源码剖析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LevelDB-%E7%9A%84%E5%85%A5%E5%8F%A3-db-h"><span class="toc-number">2.</span> <span class="toc-text">LevelDB 的入口 db.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Put"><span class="toc-number">2.1.</span> <span class="toc-text">Put</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Get"><span class="toc-number">2.2.</span> <span class="toc-text">Get</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Delete-amp-Write"><span class="toc-number">2.3.</span> <span class="toc-text">Delete &amp; Write</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E5%86%99%E7%9A%84%E6%A0%B8%E5%BF%83%E2%80%94%E2%80%94Log"><span class="toc-number">3.</span> <span class="toc-text">追加写的核心——Log</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#log-format-h"><span class="toc-number">3.1.</span> <span class="toc-text">log_format.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#log-writer-h"><span class="toc-number">3.2.</span> <span class="toc-text">log_writer.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#log-reader-h"><span class="toc-number">3.3.</span> <span class="toc-text">log_reader.h</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LevelDB-%E7%9A%84-Compaction"><span class="toc-number">4.</span> <span class="toc-text">LevelDB 的 Compaction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Minor-Compaction"><span class="toc-number">4.1.</span> <span class="toc-text">Minor Compaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Major-Compaction"><span class="toc-number">4.2.</span> <span class="toc-text">Major Compaction</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        LevelDB源码剖析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">leiysky</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-03-26T16:32:35.000Z" itemprop="datePublished">2019-03-27</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Database/">Database</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Database/" rel="tag">Database</a>, <a class="tag-link-link" href="/tags/LevelDB/" rel="tag">LevelDB</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>LevelDB</code>是谷歌开源的一款高性能嵌入式 kv 数据库，基于<code>LSM-tree</code>索引，是<code>Bigtable</code>的简化版实现（可以这么理解）。</p>
<p>它的特点是写入速度非常快，达到了<code>O(1)</code>级别的时间复杂度。但是付出的代价就是读取的速度非常慢，尤其是对于数据库中不存在的 key 进行<code>get</code>操作会扫描所有的记录。</p>
<p>对于 LevelDB 的具体设计本文就不再提及，这里主要从代码的层面分析一下 LevelDB 的结构（膜拜一下 Jeff Dean 亲手写的 C++）。</p>
<h1 id="LevelDB-的入口-db-h"><a href="#LevelDB-的入口-db-h" class="headerlink" title="LevelDB 的入口 db.h"></a>LevelDB 的入口 db.h</h1><p><code>db.h</code>中定义了<code>LevelDB</code>对外开放的接口——<code>DB</code>类。</p>
<p><code>DB</code>类的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> DB &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Status <span class="title">Open</span><span class="params">(<span class="type">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                     DB** dbptr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DB</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DB</span>(<span class="type">const</span> DB&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  DB&amp; <span class="keyword">operator</span>=(<span class="type">const</span> DB&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">DB</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Put</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> Slice&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Delete</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, <span class="type">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> Slice&amp; key, std::string* value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Iterator* <span class="title">NewIterator</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> Snapshot* <span class="title">GetSnapshot</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ReleaseSnapshot</span><span class="params">(<span class="type">const</span> Snapshot* snapshot)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">GetProperty</span><span class="params">(<span class="type">const</span> Slice&amp; property, std::string* value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetApproximateSizes</span><span class="params">(<span class="type">const</span> Range* range, <span class="type">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">uint64_t</span>* sizes)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CompactRange</span><span class="params">(<span class="type">const</span> Slice* begin, <span class="type">const</span> Slice* end)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个类里面定义了<code>Put</code>, <code>Delete</code>, <code>Get</code>, <code>Write</code>这几个<code>CURD</code>的基本操作，以及<code>LevelDB</code>支持的<code>feature</code>，获取快照等。</p>
<p>接下来，我将先从这几个基本操作入手，结合 LevelDB 的源码进行分析。</p>
<h2 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h2><p>当你调用<code>Put</code>写入一个 value 时，会发生些什么呢？</p>
<p>LevelDB 写入数据的流程非常简单：</p>
<ol>
<li>追加 Log 到 Log 文件</li>
<li>检查是否需要 compaction</li>
</ol>
<p>我们首先看看<code>Put</code>函数的实现。</p>
<p><code>LevelDB</code>本身的实现在<code>db/db_impl.h</code>和<code>db/db_impl.cc</code>中。</p>
<p><code>Put</code>的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Put</span><span class="params">(<span class="type">const</span> WriteOptions&amp; o, <span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> DB::<span class="built_in">Put</span>(o, key, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里 DBImpl 覆盖了 DB 的 Put 方法，并且在其中透传参数调用了父类的 Put。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DB::Put</span><span class="params">(<span class="type">const</span> WriteOptions&amp; opt, <span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  batch.<span class="built_in">Put</span>(key, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Put</code>的本质就是一个<code>Write</code>操作带上了自己封装的<code>Batch</code>。</p>
<p>所以我们继续来看<code>Write</code>的过程。</p>
<p>以下是精简过的<code>Write</code>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* my_batch)</span> </span>&#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = my_batch;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MakeRoomForWrite</span>(my_batch == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> last_sequence = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  WriteBatch* updates = <span class="built_in">BuildBatchGroup</span>(&amp;last_writer);</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetSequence</span>(updates, last_sequence + <span class="number">1</span>);</span><br><span class="line">  last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(updates);</span><br><span class="line"></span><br><span class="line">  log_-&gt;<span class="built_in">AddRecord</span>(WriteBatchInternal::<span class="built_in">Contents</span>(updates));</span><br><span class="line">  WriteBatchInternal::<span class="built_in">InsertInto</span>(updates, mem_);</span><br><span class="line"></span><br><span class="line">  versions_-&gt;<span class="built_in">SetLastSequence</span>(last_sequence);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先面临的一个关键步骤是<code>MakeRoomForWrite</code>。</p>
<p><code>MakeRoomForWrite</code>的作用是为<code>Write</code>制造条件，包括可用的<code>memtable</code>和 Log 的<code>writer</code>。</p>
<p><code>MakeRoomForWirte</code>内部是一个无限的 loop，参数为一个<code>bool force</code>。顾名思义其作用为强制发起一次<code>compaction</code>，触发条件为<code>mybatch==nullptr</code>，其分支情况如下：</p>
<ol>
<li>检查是否需要延迟写入<code>L0</code>文件（<code>force</code>为<code>false</code>，且<code>L0</code>文件过多时会<code>delay</code>1000ms，一次<code>MakeRoomForWrite</code>的过程最多有一次<code>delay</code>）</li>
<li>如果当前的<code>memtable</code>容量够用则跳出 loop，返回后将直接使用当前<code>memtable</code></li>
<li>检查是否有<code>immutable table</code>，如果有则表示上一次<code>compaction</code>还未完成，继续等待</li>
<li>检查<code>L0</code>文件数量，如果数量过多也说明<code>compaction</code>未完成，继续等待</li>
<li>创建新的<code>memtable</code>，并且对旧的进行<code>compaction</code>（过程为创建 Log 文件，设置<code>immutable table</code>为旧的<code>memtable</code>，创建新的<code>memtable</code>，调用<code>MaybeScheduleCompaction</code>）<br>这个函数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;<span class="built_in">NeedsCompaction</span>()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们也可以猜到，<code>MaybeScheduleCompaction</code>这个函数实际上就是<code>compaction</code>的入口。我们先来大致看一下他的内容（代码比较短，我就直接贴代码了）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;<span class="built_in">NeedsCompaction</span>()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到具体的<code>Schedule</code>是与环境相挂钩的，其执行一定会触发<code>minor compaction</code>，如果满足条件也会触发<code>major compaction</code>。LevelDB 提供了<code>Windows</code>和<code>POSIX</code>两种实现，我们之后再来看。</p>
<p>在<code>MakeRoomForWrite</code>之后，会调用<code>_log.AddRecord()</code>来追加一条 Log，并且使用<code>WriteBatchInternal::Contents(updates)</code>来写入<code>memtable</code>。</p>
<p>关于 Log 的内容会在之后展开讲，这里主要提一下，写<code>memtable</code>的过程实际上就是在<code>memtable</code>的<code>skiplist</code>中插入一条记录。</p>
<p>一次<code>Put</code>的过程就是这样，非常的简洁，这也是<code>LevelDB</code>写入速度快的原因。</p>
<h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>LevelDB 极高的写性能带来的代价就是他的读性能非常的差。</p>
<p>每次<code>Get</code>操作的读取顺序为：</p>
<ol>
<li><code>memtable</code></li>
<li><code>immutable table</code></li>
<li><code>L0</code>文件</li>
<li>高<code>Level</code>文件</li>
</ol>
<p>只有在所有的文件都被读完后才能确定目标<code>key</code>是不存在的。</p>
<p><code>Get</code>方法的脉络很清晰，因为其本质就是一个遍历查找的过程，整理后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">const</span> Slice&amp; key, std::string* value)</span> </span>&#123;</span><br><span class="line">  <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, versions_-&gt;LastSequence())</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mem_-&gt;<span class="built_in">Get</span>(lkey, value, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">NULL</span> &amp;&amp; imm_-&gt;<span class="built_in">Get</span>(lkey, value, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    versions_-&gt;<span class="built_in">current</span>()-&gt;<span class="built_in">Get</span>(options, lkey, value, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看看<code>memtable</code>的<code>Get</code>。</p>
<p>LevelDB 的<code>memtable</code>本质上是一个常规的<code>skiplist</code>，存储了有序的<code>entries</code>。所以<code>memtable</code>的<code>Get</code>操作就是使用用户提供的<code>comparator</code>去进行一个查找。</p>
<p>这里有个小细节就是每个<code>entry</code>都存储了一个<code>ValueType</code>，用于标记该<code>key</code>的类型，是<strong>插入</strong>还是<strong>删除</strong>。</p>
<p>我们知道 LevelDB 的删除本质上也是追加一条记录，在<code>compaction</code>的时候才会真正的删除掉<code>key</code>。</p>
<p>LevelDB 的写入方式保证了<code>Get</code>能从最新的数据开始读，因此如果读到了一个指定<code>key</code>的删除记录，则可以确定该<code>key</code>已经不存在了。</p>
<p><code>immutable table</code>的结构与<code>memtable</code>是相同的，不同点在于它是不可变的，相当于是一个<code>memtable</code>与<code>SSTable</code>文件之间的缓冲。</p>
<p>接下来我们看看<code>version</code>的<code>Get</code>操作。</p>
<p>在<code>version</code>的<code>Get</code>操作中有一个比较重要的概念——<code>FileMetaData</code>。</p>
<p><code>FileMetaData</code>的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FileMetaData</span> &#123;</span><br><span class="line">  <span class="type">int</span> refs;</span><br><span class="line">  <span class="type">int</span> allowed_seeks;          <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="type">uint64_t</span> number;</span><br><span class="line">  <span class="type">uint64_t</span> file_size;         <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;       <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;        <span class="comment">// Largest internal key served by table</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">FileMetaData</span>() : <span class="built_in">refs</span>(<span class="number">0</span>), <span class="built_in">allowed_seeks</span>(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="built_in">file_size</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到其中定义了一个<code>smallest</code>和<code>largest</code>，它们描述了文件中存储的<code>key</code>的区间。我们在读取的时候可以根据这个区间确定<code>key</code>是否在该文件中，这样加快了<code>key</code>的定位速度。</p>
<p><code>version</code>的<code>Get</code>过程也十分简单粗暴，逐层检索<code>key</code>，找到为止。</p>
<h2 id="Delete-amp-Write"><a href="#Delete-amp-Write" class="headerlink" title="Delete &amp; Write"></a>Delete &amp; Write</h2><p><code>Delete</code>其实就是<code>Put</code>，而<code>Put</code>的本质是<code>Write</code>，这两个操作就不再展开讲。</p>
<h1 id="追加写的核心——Log"><a href="#追加写的核心——Log" class="headerlink" title="追加写的核心——Log"></a>追加写的核心——Log</h1><p>LSM 树的思想是将内存中维护的树定期 flush 到磁盘上持久化，以提高写入的性能。但是我们知道内存中的数据是 Volatile 的，这就需要 log 来保证数据的持久性。</p>
<p>Log 相关的代码主要有<code>log_format.h</code>, <code>log_reader.h</code>, <code>log_writer.h</code>。</p>
<h2 id="log-format-h"><a href="#log-format-h" class="headerlink" title="log_format.h"></a>log_format.h</h2><p>这个文件中定义了<code>log</code>的格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">RecordType</span> &#123;</span><br><span class="line">  <span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line">  kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For fragments</span></span><br><span class="line">  kFirstType = <span class="number">2</span>,</span><br><span class="line">  kMiddleType = <span class="number">3</span>,</span><br><span class="line">  kLastType = <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kMaxRecordType = kLastType;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kBlockSize = <span class="number">32768</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is checksum (4 bytes), length (2 bytes), type (1 byte).</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kHeaderSize = <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们知道 LevelDB 的 log 是连续存储在文件中的（为了最大化顺序读写的性能，每次将一条<code>Record</code>写入文件），每条 Log 都有一个 header 存储相关的元信息。这里的元信息为三个：<code>CRC</code>校验码，Log 内容长度，Log 位置信息。</p>
<p>LevelDB 的日志每个块的大小是固定的（为了对齐 32K），因此 Log 的数据有可能会被切分到不同的块。这里我们可以知道有四种位置关系，分别是：</p>
<ul>
<li>整个 Log 在该块中</li>
<li>Log 的开头在该块中</li>
<li>Log 的中间部分在该块中（占据整个块）</li>
<li>Log 的尾部在该块中</li>
</ul>
<p>那么这个<code>kZeroType</code>是做什么的呢？</p>
<p>考虑这种情况，一个块在写入后只剩下不到 7 个字节的空间，不足以塞下一个 header。</p>
<p>这时 LevelDB 会选择使用<code>\x00</code>来填充剩余的空间。</p>
<p>当剩余 7 个字节时，则塞入一个<code>kZeroType</code>的 header。</p>
<h2 id="log-writer-h"><a href="#log-writer-h" class="headerlink" title="log_writer.h"></a>log_writer.h</h2><p><code>log_writer.h</code>中定义了一个<code>Writer</code>类，它的主要方法只有一个，就是<code>AddRecord</code>，也就是我们之前在<code>Put</code>中看到的追加 Log 的操作。</p>
<p><code>AddRecord</code>的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="type">const</span> Slice&amp; slice)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ptr = slice.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">size_t</span> left = slice.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line">  <span class="comment">// zero-length record</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="type">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">    <span class="built_in">assert</span>(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="built_in">assert</span>(kHeaderSize == <span class="number">7</span>);</span><br><span class="line">        dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(<span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    <span class="built_in">assert</span>(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="built_in">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里唯一要注意的就是剩余空间不足时的处理方式，前面已经提过了。</p>
<p>在<code>EmitPhysicalRecord</code>中则会将发生的更改<code>flush</code>到磁盘上。</p>
<h2 id="log-reader-h"><a href="#log-reader-h" class="headerlink" title="log_reader.h"></a>log_reader.h</h2><p><code>log_reader.h</code>中主要定义了<code>Reader</code>，用于读取 Log。</p>
<p>和<code>Writer</code>相对应，<code>Reader</code>的主要方法就是一个<code>ReadRecord</code>。</p>
<p><code>ReadRecord</code>的逻辑也很简单：</p>
<ul>
<li>使用<code>ReadPhysicalRecord</code>读取<code>record</code>，这个过程会做<code>CRC</code>校验</li>
<li>根据<code>Type</code>选择处理方式</li>
</ul>
<h1 id="LevelDB-的-Compaction"><a href="#LevelDB-的-Compaction" class="headerlink" title="LevelDB 的 Compaction"></a>LevelDB 的 Compaction</h1><p>LSM 中，数据合并的过程叫做<code>Compaction</code>，其中有三种：</p>
<ul>
<li><code>Minor Compaction</code>: 内存中的树与磁盘文件合并</li>
<li><code>Major Compaction</code>: SSTable 与上层 SSTable 文件合并</li>
<li><code>Full Compaction</code>: 全部合并</li>
</ul>
<p>LevelDB 实现了<code>Minor Compaction</code>和<code>Major Compaction</code>。</p>
<p>我们在前面有提到<code>MaybeScheduleCompaction</code>这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;<span class="built_in">NeedsCompaction</span>()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>env_-&gt;Schedule</code>传入的参数<code>DBImpl::BGWork</code>就是实际运行<code>Compaction</code>过程的函数指针，我们来看看其实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::BGWork</span><span class="params">(<span class="type">void</span>* db)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;DBImpl*&gt;(db)-&gt;<span class="built_in">BackgroundCall</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::BackgroundCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">BackgroundCompaction</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">  <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">  background_work_finished_signal_.<span class="built_in">SignalAll</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DBImpl::BGWork</code>中直接调用了入口函数<code>DBImpl::BackgroundCall</code>。在后者中，调用了<code>BackgroundCompaction</code>。</p>
<p><code>DBImpl::BackgroundCompaction</code>是一个比较长的函数，简化后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 去掉了manual模式的相关内容</span></span><br><span class="line">  <span class="built_in">CompactMemtable</span>();</span><br><span class="line">  Compaction* c;</span><br><span class="line">  c = versions_-&gt;<span class="built_in">PickCompaction</span>();</span><br><span class="line">  CompactionState* compact = <span class="keyword">new</span> <span class="built_in">CompactionState</span>(c);</span><br><span class="line">  <span class="built_in">DoCompactionWork</span>(compact);</span><br><span class="line">  <span class="built_in">CleanupCompaction</span>(compact);</span><br><span class="line">  c-&gt;<span class="built_in">ReleaseInputs</span>();</span><br><span class="line">  <span class="built_in">DeleteObsoleteFiles</span>();</span><br><span class="line">  <span class="keyword">delete</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minor-Compaction"><a href="#Minor-Compaction" class="headerlink" title="Minor Compaction"></a>Minor Compaction</h2><p>首先来看看<code>CompactMemtable</code>这个函数(同样是简化版)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  base-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  Status s = <span class="built_in">WriteLevel0Table</span>(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  edit.<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);</span><br><span class="line">  edit.<span class="built_in">SetLogNumber</span>(logfile_number_);</span><br><span class="line">  s = versions_-&gt;<span class="built_in">LogAndApply</span>(&amp;edit, &amp;mutex_);</span><br><span class="line">  imm_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">  has_imm_.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release);</span><br><span class="line">  <span class="built_in">DeleteObsoleteFiles</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道<code>memtable</code>的<code>compaction</code>过程为：</p>
<ol>
<li>将当前的<code>memtable</code>切换为<code>immutable memtable</code></li>
<li>将<code>immutable memtable</code>转换为 SSTable 文件</li>
</ol>
<p>这里为了保证写操作不被阻塞，首先会生成一个相同的<code>memtable</code>，将其作为<code>imm</code>，并尝试使用<code>WriteLevel0Table</code>进行<code>compaction</code>。</p>
<p><code>WriteLevel0Table</code>的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Version* base)</span> </span>&#123;</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">  pending_outputs_.<span class="built_in">insert</span>(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;<span class="built_in">NewIterator</span>();</span><br><span class="line">  Status s;</span><br><span class="line">  s = <span class="built_in">BuildTable</span>(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.<span class="built_in">erase</span>(meta.number);</span><br><span class="line">  <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> Slice min_user_key = meta.smallest.<span class="built_in">user_key</span>();</span><br><span class="line">  <span class="type">const</span> Slice max_user_key = meta.largest.<span class="built_in">user_key</span>();</span><br><span class="line">  level = base-&gt;<span class="built_in">PickLevelForMemTableOutput</span>(min_user_key, max_user_key);</span><br><span class="line">  edit-&gt;<span class="built_in">AddFile</span>(level, meta.number, meta.file_size,</span><br><span class="line">                  meta.smallest, meta.largest);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键步骤是<code>BuildTable</code>，这个函数将会把 memtable 的具体内容写入指定的文件。</p>
<p>这一块的嵌套会有点深，<code>BuildTable</code>是在<code>builder.cc</code>里面实现的函数，本质上是构造了一个<code>TableBuilder</code>来创建 SSTable，所以我们直接看<code>TableBuilder</code>相关的内容。</p>
<p><code>TableBuilder</code>相关的文件为<code>table_builder.h</code>和<code>table_builder.cc</code>。</p>
<p><code>TableBuilder</code>的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TableBuilder</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TableBuilder</span>(<span class="type">const</span> Options&amp; options, WritableFile* file);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TableBuilder</span>(<span class="type">const</span> TableBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> TableBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">TableBuilder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">ChangeOptions</span><span class="params">(<span class="type">const</span> Options&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Abandon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">NumEntries</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">FileSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">status</span>().<span class="built_in">ok</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">WriteRawBlock</span><span class="params">(<span class="type">const</span> Slice&amp; data, CompressionType, BlockHandle* handle)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Rep</span>;</span><br><span class="line">  Rep* rep_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类的使用方法也很简单明了，构造出实例后调用<code>Add</code>向 Table 中写入记录，之后调用<code>Finish</code>或者<code>Abandon</code>来完成 Table 的构建，再销毁实例。</p>
<p>我们主要关注<code>Add</code>这个函数的实现(精简版本)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">    <span class="comment">// data block为空时才会进入该分支</span></span><br><span class="line">    r-&gt;options.comparator-&gt;<span class="built_in">FindShortestSeparator</span>(&amp;r-&gt;last_key, key);</span><br><span class="line">    std::string handle_encoding;</span><br><span class="line">    r-&gt;pending_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">    r-&gt;index_block.<span class="built_in">Add</span>(r-&gt;last_key, <span class="built_in">Slice</span>(handle_encoding));</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;filter_block-&gt;<span class="built_in">AddKey</span>(key);</span><br><span class="line">  r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">  r-&gt;num_entries++;</span><br><span class="line">  r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> estimated_block_size = r-&gt;data_block.<span class="built_in">CurrentSizeEstimate</span>();</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码需要对照 SSTable 的结构来看，这里有一张图：<br><img src="https://leveldb-handbook.readthedocs.io/zh/latest/_images/sstable_logic.jpeg"></p>
<p>SSTable 文件中分为数据块和 meta 块，每个数据块就是具体的 Key-VAlue，meta 块又分成：</p>
<ul>
<li><code>Filter Block</code>: 布隆过滤器块，用于加快 Key 的查找</li>
<li><code>Meta Index Block</code>: 记录<code>Filter Block</code>的相关元信息，比如索引数据块偏移和过滤数据块偏移</li>
<li><code>Index Block</code>: 记录数据块索引</li>
<li><code>Footer</code>: 其他的 meta 信息</li>
</ul>
<p>根据以上的代码逻辑，我们可以知道，每次<code>Add</code>的过程为：</p>
<ol>
<li>编码数据</li>
<li>插入索引数据</li>
<li>插入过滤数据</li>
<li>插入数据块</li>
</ol>
<p>我们将把重点放在 2, 3, 4 步骤上。</p>
<p>插入索引数据和插入 KV 数据都是使用的<code>BlockBuilder</code>。</p>
<p><code>BlockBuilder</code>与<code>TableBuilder</code>的接口基本一致，因此我们也是主要关注它的<code>Add</code>接口。</p>
<p><code>Add</code>的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="function">Slice <span class="title">last_key_piece</span><span class="params">(last_key_)</span></span>;</span><br><span class="line">  <span class="type">size_t</span> shared = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> min_length = std::<span class="built_in">min</span>(last_key_piece.<span class="built_in">size</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</span><br><span class="line">    shared++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> non_shared = key.<span class="built_in">size</span>() - shared;</span><br><span class="line">  <span class="built_in">PutVarint32</span>(&amp;buffer_, shared);</span><br><span class="line">  <span class="built_in">PutVarint32</span>(&amp;buffer_, non_shared);</span><br><span class="line">  <span class="built_in">PutVarint32</span>(&amp;buffer_, value.<span class="built_in">size</span>());</span><br><span class="line">  buffer_.<span class="built_in">append</span>(key.<span class="built_in">data</span>() + shared, non_shared);</span><br><span class="line">  buffer_.<span class="built_in">append</span>(value.<span class="built_in">data</span>(), value.<span class="built_in">size</span>());</span><br><span class="line">  last_key_.<span class="built_in">resize</span>(shared);</span><br><span class="line">  last_key_.<span class="built_in">append</span>(key.<span class="built_in">data</span>() + shared, non_shared);</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Slice</span>(last_key_) == key);</span><br><span class="line">  counter_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Index Block</code>的结构如下图：<br><img src="https://leveldb-handbook.readthedocs.io/zh/latest/_images/indexblock_format.jpeg"></p>
<p>可以看到每一条索引记录存储的实际上是一个<code>Max Key</code>，加上偏移与长度。</p>
<p>这里必须要提到的是，LevelDB在存储Key-Value时并不一定会存储完整的<code>Key</code>，而是会存储下<strong>与前一条记录的Key不共享的部分</strong>。</p>
<p><code>Data Block</code>的存储方式如下图：<br><img src="https://leveldb-handbook.readthedocs.io/zh/latest/_images/entry_format.jpeg"></p>
<p>举个例子：</p>
<ul>
<li><code>abc</code>, <code>acc</code>这两个连续的<code>Key</code>在存储时，<code>Unshared key</code>分别为<code>abc</code>和<code>cc</code>。</li>
</ul>
<p>除此之外，LevelDB还有一个<code>Restart Point</code>的设计，会每隔几条记录存储一个完整的<code>Key</code>。这个记录数的默认值为<code>16</code>。</p>
<p>对于索引块的插入，调用方式为<code>r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding))</code>。</p>
<p>这里<code>r-&gt;last_key</code>的值来源于<code>r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key)</code>。</p>
<p><code>FindShortestSeparator</code>实际上是一个非常有意思的函数，它的字面意思是找出最短的分隔符。</p>
<p>那么这里的分隔符是什么呢？答案就是<code>Index Block</code>中的<code>Max Key</code>。</p>
<p><code>TableBuilder</code>并不会在一开始构造时就找出<code>Max Key</code>，而是等到下一个<code>Data Block</code>的第一个<code>Key</code>出现时做这件事。</p>
<p>它会取出前一个<code>Data Block</code>的最后一个<code>Key</code>，也就是前一个<code>Data Block</code>中最大的，与后一个<code>Data Block</code>的第一个<code>Key</code>的最长公有前缀，并将其后一位的字符+1，作为<code>Max Key</code>。</p>
<p>比如说，前一个<code>Data Block</code>的最后一个<code>Key</code>为<code>abcd</code>，后一个<code>Data Block</code>的第一个<code>Key</code>为<code>abcf</code>，那么他们的最长前缀为<code>abc</code>，取出的<code>Max Key</code>为<code>abce</code>(<code>e</code>为<code>d+1</code>)。</p>
<p>这样以来可以保证前一个<code>Data Block</code>中的所有数据都会小于<code>Max Key</code>，也不会对后面的<code>Data Block</code>产生影响，还节约了存储空间，十分的巧妙。</p>
<p>关于布隆过滤器这里就不再展开讲。</p>
<h2 id="Major-Compaction"><a href="#Major-Compaction" class="headerlink" title="Major Compaction"></a>Major Compaction</h2><p>看完了<code>memtable</code>的<code>minor compaction</code>，我们来看看<code>SSTable</code>的<code>major compaction</code>。</p>
<p>与<code>minor compaction</code>不同，<code>major compaction</code>的过程比较复杂，它涉及到两个<code>level</code>之间有重叠<code>key</code>的<code>SSTable</code>的合并。</p>
<p>这部分会单独开一篇博客来分析。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/leiysky">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LevelDB-%E7%9A%84%E5%85%A5%E5%8F%A3-db-h"><span class="toc-number">2.</span> <span class="toc-text">LevelDB 的入口 db.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Put"><span class="toc-number">2.1.</span> <span class="toc-text">Put</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Get"><span class="toc-number">2.2.</span> <span class="toc-text">Get</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Delete-amp-Write"><span class="toc-number">2.3.</span> <span class="toc-text">Delete &amp; Write</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E5%86%99%E7%9A%84%E6%A0%B8%E5%BF%83%E2%80%94%E2%80%94Log"><span class="toc-number">3.</span> <span class="toc-text">追加写的核心——Log</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#log-format-h"><span class="toc-number">3.1.</span> <span class="toc-text">log_format.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#log-writer-h"><span class="toc-number">3.2.</span> <span class="toc-text">log_writer.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#log-reader-h"><span class="toc-number">3.3.</span> <span class="toc-text">log_reader.h</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LevelDB-%E7%9A%84-Compaction"><span class="toc-number">4.</span> <span class="toc-text">LevelDB 的 Compaction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Minor-Compaction"><span class="toc-number">4.1.</span> <span class="toc-text">Minor Compaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Major-Compaction"><span class="toc-number">4.2.</span> <span class="toc-text">Major Compaction</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&text=LevelDB源码剖析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=LevelDB源码剖析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&is_video=false&description=LevelDB源码剖析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=LevelDB源码剖析&body=Check out this article: http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=LevelDB源码剖析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=LevelDB源码剖析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=LevelDB源码剖析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=LevelDB源码剖析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&name=LevelDB源码剖析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2019/03/27/LevelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&t=LevelDB源码剖析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022
    leiysky
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/leiysky">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
